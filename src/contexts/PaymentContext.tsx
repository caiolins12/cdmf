import React, { createContext, useContext, useCallback, useMemo, useState, useEffect } from "react";
import { doc, setDoc, collection, query, where, getDocs, updateDoc, deleteDoc, orderBy, Timestamp, onSnapshot, getDoc, arrayUnion } from "firebase/firestore";
import { db } from "../services/firebase";
import { useAuth, Profile, Class, PaymentNotification } from "./AuthContext";

// Fun√ß√£o segura para formatar data no formato DD/MM/YYYY
const formatDateSafe = (dateStr: any): string => {
  if (!dateStr || typeof dateStr !== 'string') return '--/--/----';
  try {
    return dateStr.split("-").reverse().join("/");
  } catch {
    return '--/--/----';
  }
};

// ==================== TIPOS ====================

export type PaymentStatus = "pending" | "paid" | "overdue" | "cancelled";

export type PaymentMethod = "pix" | "pix_mercadopago" | "cash" | "card" | "transfer";

// Cobran√ßa/Fatura
export type Invoice = {
  id: string;
  studentId: string;
  studentName: string;
  studentEmail: string;
  amount: number; // em centavos - valor atual a pagar
  originalAmount: number; // valor sem desconto (em centavos)
  discountAmount: number; // valor do desconto (em centavos)
  description: string;
  dueDate: string; // "YYYY-MM-DD" - data limite para desconto
  lateDueDate: string; // "YYYY-MM-DD" - data limite final
  status: PaymentStatus;
  referenceMonth: string; // "2025-01" (para mensalidades)
  classIds?: string[]; // turmas relacionadas
  classCount: number; // n√∫mero de turmas
  createdAt: number;
  createdBy: string;
  updatedAt?: number;
  paidAt?: number;
  paidMethod?: PaymentMethod;
  pixCode?: string; // C√≥digo PIX gerado
  pixExpiration?: number; // Timestamp de expira√ß√£o do PIX
  notes?: string;
  // Flags de controle
  isAutoGenerated?: boolean; // gerada automaticamente
  // Mercado Pago espec√≠fico
  mpPaymentId?: number; // ID do pagamento no Mercado Pago
  mpStatus?: string; // Status no Mercado Pago (pending, approved, etc)
  pixQrCodeBase64?: string; // QR Code em base64 do MP
  pixTicketUrl?: string; // URL do ticket de pagamento
  pixExpiresAt?: number; // Timestamp de expira√ß√£o do PIX MP
};

// Transa√ß√£o (entrada ou sa√≠da)
export type Transaction = {
  id: string;
  type: "income" | "expense";
  category: string; // "mensalidade", "material", "salario", "aluguel", etc.
  description: string;
  amount: number; // em centavos
  date: string; // "YYYY-MM-DD"
  invoiceId?: string; // refer√™ncia √† fatura (se for pagamento)
  studentId?: string;
  studentName?: string;
  teacherId?: string;
  teacherName?: string;
  paymentMethod?: PaymentMethod;
  createdAt: number;
  createdBy: string;
  notes?: string;
};

// Pre√ßo por n√∫mero de turmas
export type TierPricing = {
  classes: number; // n√∫mero de turmas
  earlyPrice: number; // pre√ßo com desconto (em centavos)
  regularPrice: number; // pre√ßo normal (em centavos)
};

// Configura√ß√µes de pagamento
export type PaymentSettings = {
  monthlyFee: number; // valor padr√£o da mensalidade em centavos (1 turma, sem desconto)
  pixKey: string; // chave PIX do estabelecimento
  pixKeyType: "cpf" | "cnpj" | "email" | "phone" | "random";
  pixReceiverName: string; // nome do recebedor
  pixCity: string; // cidade do recebedor
  dueDayOfMonth: number; // dia do vencimento com desconto (ex: dia 1)
  gracePeriodDays: number; // dias de toler√¢ncia antes de marcar como atrasado
  latePaymentDeadline: number; // √∫ltimo dia para pagamento (ex: dia 8)
  // Tabela de pre√ßos por turmas
  tierPricing: TierPricing[];
  // Controle de atualiza√ß√£o
  updatedAt?: number;
};

// Resumo financeiro
export type FinancialSummary = {
  totalReceived: number;
  totalPending: number;
  totalOverdue: number;
  totalExpenses: number;
  balance: number;
  invoicesCount: {
    paid: number;
    pending: number;
    overdue: number;
  };
};

// ==================== CONTEXTO ====================

type PaymentContextType = {
  // Faturas
  createInvoice: (data: Omit<Invoice, "id" | "createdAt" | "createdBy" | "status">) => Promise<string>;
  fetchInvoices: (filters?: { studentId?: string; status?: PaymentStatus; month?: string }) => Promise<Invoice[]>;
  updateInvoice: (id: string, data: Partial<Invoice>) => Promise<void>;
  deleteInvoice: (id: string) => Promise<void>;
  markAsPaid: (invoiceId: string, method: PaymentMethod, notes?: string) => Promise<void>;
  markAsOverdue: (invoiceId: string) => Promise<void>;
  
  // Transa√ß√µes
  createTransaction: (data: Omit<Transaction, "id" | "createdAt" | "createdBy">) => Promise<string>;
  fetchTransactions: (filters?: { type?: "income" | "expense"; month?: string }) => Promise<Transaction[]>;
  deleteTransaction: (id: string) => Promise<void>;
  
  // PIX
  generatePixCode: (invoice: Invoice) => Promise<string>;
  
  // Relat√≥rios
  getFinancialSummary: (month?: string) => Promise<FinancialSummary>;
  
  // Cobran√ßas em lote
  generateMonthlyInvoices: (students: Profile[], month: string) => Promise<number>;
  
  // Atualiza√ß√£o autom√°tica de status
  updateOverdueInvoices: () => Promise<number>;
  
  // Configura√ß√µes
  getPaymentSettings: () => Promise<PaymentSettings | null>;
  updatePaymentSettings: (settings: Partial<PaymentSettings>) => Promise<void>;
  
  // C√°lculo de pre√ßos
  calculatePriceForStudent: (classCount: number, settings: PaymentSettings) => { earlyPrice: number; regularPrice: number; discount: number };
  
  // Gera√ß√£o autom√°tica de fatura para aluno
  generateInvoiceForStudent: (student: Profile, month: string) => Promise<Invoice | null>;
  
  // Listeners em tempo real
  subscribeToInvoices: (studentId: string, callback: (invoices: Invoice[]) => void) => () => void;
  subscribeToAllInvoices: (callback: (invoices: Invoice[]) => void, filters?: { status?: PaymentStatus | PaymentStatus[]; month?: string }) => () => void;
  subscribeToSettings: (callback: (settings: PaymentSettings | null) => void) => () => void;
  
  // Administra√ß√£o
  clearAllFinancialData: () => Promise<{ invoices: number; transactions: number; studentsUpdated: number }>;
};

const PaymentContext = createContext<PaymentContextType>({} as PaymentContextType);

// ==================== FUN√á√ïES AUXILIARES ====================

// Formata valor de centavos para BRL
export function formatCurrency(cents: number | undefined | null): string {
  if (cents === undefined || cents === null || isNaN(cents)) {
    return "R$ 0,00";
  }
  return new Intl.NumberFormat("pt-BR", {
    style: "currency",
    currency: "BRL",
  }).format(cents / 100);
}

// Converte reais para centavos
export function toCents(value: number): number {
  return Math.round(value * 100);
}

// Converte centavos para reais
export function toReais(cents: number): number {
  return cents / 100;
}

// Gera ID √∫nico
function generateId(prefix: string): string {
  return `${prefix}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
}

// Verifica se uma data est√° vencida
function isOverdue(dueDate: string): boolean {
  const today = new Date();
  today.setHours(0, 0, 0, 0);
  const due = new Date(dueDate + "T00:00:00");
  return due < today;
}

// Nome do m√™s em portugu√™s
function getMonthName(month: number): string {
  const months = [
    "Janeiro", "Fevereiro", "Mar√ßo", "Abril", "Maio", "Junho",
    "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"
  ];
  return months[month - 1] || "";
}

// Gera payload PIX (EMV QR Code est√°tico simplificado)
function generatePixPayload(
  pixKey: string,
  pixKeyType: string,
  receiverName: string,
  city: string,
  amount: number,
  txId: string,
  description: string
): string {
  // Implementa√ß√£o simplificada do payload PIX
  // Em produ√ß√£o, usar biblioteca espec√≠fica como 'pix-payload' ou API do banco
  
  const amountStr = (amount / 100).toFixed(2);
  
  // Monta payload EMV
  const payload = [
    "00020126", // Payload Format Indicator
    formatEMVField("26", [
      "0014BR.GOV.BCB.PIX",
      formatEMVField("01", pixKey),
    ].join("")),
    "52040000", // Merchant Category Code
    "5303986", // Transaction Currency (986 = BRL)
    formatEMVField("54", amountStr),
    "5802BR", // Country Code
    formatEMVField("59", receiverName.substring(0, 25)),
    formatEMVField("60", city.substring(0, 15)),
    formatEMVField("62", formatEMVField("05", txId.substring(0, 25))),
  ].join("");
  
  // Adiciona CRC16
  const crc = calculateCRC16(payload + "6304");
  return payload + "6304" + crc;
}

function formatEMVField(id: string, value: string): string {
  const len = value.length.toString().padStart(2, "0");
  return id + len + value;
}

function calculateCRC16(str: string): string {
  // CRC16-CCITT-FALSE
  let crc = 0xFFFF;
  for (let i = 0; i < str.length; i++) {
    crc ^= str.charCodeAt(i) << 8;
    for (let j = 0; j < 8; j++) {
      if (crc & 0x8000) {
        crc = (crc << 1) ^ 0x1021;
      } else {
        crc <<= 1;
      }
    }
  }
  return (crc & 0xFFFF).toString(16).toUpperCase().padStart(4, "0");
}

// ==================== PROVIDER ====================

export function PaymentProvider({ children }: { children: React.ReactNode }) {
  const { profile } = useAuth();

  // ========== FATURAS ==========

  // Tipos de notifica√ß√£o relacionados a cobran√ßa (devem ser √∫nicos por fatura)
  const BILLING_NOTIFICATION_TYPES = ["billing", "pending_invoice", "reminder", "overdue"];
  
  // Envia notifica√ß√£o para o perfil do aluno
  // Se j√° existir uma notifica√ß√£o de cobran√ßa para a mesma fatura, substitui pelo novo status
  const sendNotificationToStudent = useCallback(async (
    studentId: string,
    notification: Omit<PaymentNotification, "id" | "createdAt" | "createdBy">
  ): Promise<void> => {
    if (!profile) return;
    
    try {
      const studentRef = doc(db, "profiles", studentId);
      const studentSnap = await getDoc(studentRef);
      
      if (!studentSnap.exists()) {
        console.warn(`Perfil do aluno ${studentId} n√£o encontrado para enviar notifica√ß√£o`);
        return;
      }
      
      const studentData = studentSnap.data() as Profile;
      
      // N√£o envia notifica√ß√£o para alunos offline (n√£o t√™m acesso ao app)
      if (studentData.isOffline) {
        return;
      }
      
      const existingNotifications: PaymentNotification[] = studentData.pendingNotifications || [];
      const isBillingNotification = BILLING_NOTIFICATION_TYPES.includes(notification.type);
      
      // Se for notifica√ß√£o de cobran√ßa e tem invoiceId, verifica duplicatas
      if (isBillingNotification && notification.invoiceId) {
        // Verifica se j√° existe uma notifica√ß√£o de cobran√ßa para esta fatura
        const existingIndex = existingNotifications.findIndex(
          n => n.invoiceId === notification.invoiceId && BILLING_NOTIFICATION_TYPES.includes(n.type)
        );
        
        if (existingIndex !== -1) {
          const existingNotif = existingNotifications[existingIndex];
          
          // Se o tipo √© o mesmo, n√£o faz nada (evita duplicata exata)
          if (existingNotif.type === notification.type) {
            console.log(`Notifica√ß√£o ${notification.type} j√° existe para fatura ${notification.invoiceId}`);
            return;
          }
          
          // Substitui a notifica√ß√£o existente pelo novo status
          const updatedNotifications = [...existingNotifications];
          updatedNotifications[existingIndex] = {
            ...notification,
            id: existingNotif.id, // Mant√©m o mesmo ID
            createdAt: Date.now(), // Atualiza timestamp
            createdBy: profile.uid,
          };
          
          await updateDoc(studentRef, {
            pendingNotifications: updatedNotifications,
          });
          
          console.log(`Notifica√ß√£o atualizada de ${existingNotif.type} para ${notification.type} - ${studentData.name}`);
          return;
        }
      }
      
      // Se for notifica√ß√£o de pagamento confirmado, remove notifica√ß√µes de cobran√ßa da mesma fatura
      if (notification.type === "payment_confirmed" && notification.invoiceId) {
        const filteredNotifications = existingNotifications.filter(
          n => !(n.invoiceId === notification.invoiceId && BILLING_NOTIFICATION_TYPES.includes(n.type))
        );
        
        const fullNotification: PaymentNotification = {
          ...notification,
          id: generateId("NOTIF"),
          createdAt: Date.now(),
          createdBy: profile.uid,
        };
        
        await updateDoc(studentRef, {
          pendingNotifications: [...filteredNotifications, fullNotification],
        });
        
        console.log(`Notifica√ß√£o de pagamento confirmado enviada para ${studentData.name}`);
        return;
      }
      
      // Caso padr√£o: adiciona nova notifica√ß√£o
      const fullNotification: PaymentNotification = {
        ...notification,
        id: generateId("NOTIF"),
        createdAt: Date.now(),
        createdBy: profile.uid,
      };
      
      await updateDoc(studentRef, {
        pendingNotifications: [...existingNotifications, fullNotification],
      });
      
      console.log(`Notifica√ß√£o enviada para ${studentData.name}`);
    } catch (error) {
      console.error("Erro ao enviar notifica√ß√£o para aluno:", error);
    }
  }, [profile]);

  const createInvoice = useCallback(async (
    data: Omit<Invoice, "id" | "createdAt" | "createdBy" | "status">
  ): Promise<string> => {
    if (!profile) throw new Error("Usu√°rio n√£o autenticado");

    const id = generateId("INV");
    const invoice: Invoice = {
      ...data,
      id,
      status: "pending",
      createdAt: Date.now(),
      createdBy: profile.uid,
    };

    await setDoc(doc(db, "invoices", id), invoice);
    
    // Envia notifica√ß√£o para o aluno
    await sendNotificationToStudent(data.studentId, {
      type: "billing",
      title: "Nova cobran√ßa gerada",
      message: `Uma cobran√ßa de ${formatCurrency(data.amount)} foi gerada para voc√™.`,
      invoiceId: id,
      amount: data.amount,
      dueDate: data.dueDate,
    });
    
    // Cria atividade para o log de atividades recentes
    try {
      const activityId = generateId("ACT");
      const activitiesRef = collection(db, "activities");
      await setDoc(doc(activitiesRef, activityId), {
        id: activityId,
        type: "invoice_generated",
        title: "Cobran√ßa personalizada gerada",
        description: `Cobran√ßa de ${formatCurrency(data.amount)} gerada para ${data.studentName}`,
        timestamp: Date.now(),
        metadata: {
          studentId: data.studentId,
          studentName: data.studentName,
          invoiceId: id,
          amount: data.amount,
        },
        read: false,
        createdBy: profile.uid,
      });
    } catch (e) {
      console.warn("Erro ao criar atividade:", e);
    }
    
    return id;
  }, [profile, sendNotificationToStudent]);

  const fetchInvoices = useCallback(async (
    filters?: { studentId?: string; status?: PaymentStatus; month?: string }
  ): Promise<Invoice[]> => {
    try {
      const invoicesRef = collection(db, "invoices");
      let constraints: any[] = [];

      if (filters?.studentId) {
        constraints.push(where("studentId", "==", filters.studentId));
      }
      if (filters?.status) {
        constraints.push(where("status", "==", filters.status));
      }
      if (filters?.month) {
        constraints.push(where("referenceMonth", "==", filters.month));
      }

      const q = constraints.length > 0 
        ? query(invoicesRef, ...constraints)
        : query(invoicesRef);
      
      const snap = await getDocs(q);
      const invoices = snap.docs.map(d => d.data() as Invoice);
      
      // Ordena por data de vencimento
      return invoices.sort((a, b) => 
        new Date(a.dueDate).getTime() - new Date(b.dueDate).getTime()
      );
    } catch (e) {
      console.error("Erro ao buscar faturas:", e);
      return [];
    }
  }, []);

  const updateInvoice = useCallback(async (id: string, data: Partial<Invoice>): Promise<void> => {
    const ref = doc(db, "invoices", id);
    await updateDoc(ref, { ...data, updatedAt: Date.now() });
  }, []);

  const deleteInvoice = useCallback(async (id: string): Promise<void> => {
    await deleteDoc(doc(db, "invoices", id));
  }, []);

  const markAsPaid = useCallback(async (
    invoiceId: string, 
    method: PaymentMethod, 
    notes?: string
  ): Promise<void> => {
    if (!profile) throw new Error("Usu√°rio n√£o autenticado");

    const ref = doc(db, "invoices", invoiceId);
    const now = Date.now();
    
    // Verifica se a fatura j√° foi paga (evita duplicidade)
    const invoiceSnap = await getDocs(query(collection(db, "invoices"), where("id", "==", invoiceId)));
    if (!invoiceSnap.empty) {
      const invoiceData = invoiceSnap.docs[0].data() as Invoice;
      if (invoiceData.status === "paid") {
        throw new Error("Esta fatura j√° foi paga!");
      }
      if (invoiceData.status === "cancelled") {
        throw new Error("Esta fatura foi cancelada e n√£o pode ser paga.");
      }
    }
    
    // Atualiza a fatura
    await updateDoc(ref, {
      status: "paid",
      paidAt: now,
      paidMethod: method,
      updatedAt: now,
      ...(notes ? { notes } : {}),
    });

    // Busca dados da fatura para criar transa√ß√£o
    const invoicesRef = collection(db, "invoices");
    const q = query(invoicesRef, where("id", "==", invoiceId));
    const snap = await getDocs(q);
    
    if (!snap.empty) {
      const invoice = snap.docs[0].data() as Invoice;
      
      // Cria transa√ß√£o de entrada
      const transactionId = generateId("TXN");
      const transaction: Transaction = {
        id: transactionId,
        type: "income",
        category: "mensalidade",
        description: `Pagamento - ${invoice.studentName} (${invoice.referenceMonth})`,
        amount: invoice.amount,
        date: new Date().toISOString().split("T")[0],
        invoiceId,
        studentId: invoice.studentId,
        studentName: invoice.studentName,
        paymentMethod: method,
        createdAt: now,
        createdBy: profile.uid,
      };

      await setDoc(doc(db, "transactions", transactionId), transaction);
      
      // Atualiza status de pagamento do aluno
      try {
        const studentRef = doc(db, "profiles", invoice.studentId);
        const studentSnap = await getDoc(studentRef);
        if (studentSnap.exists()) {
          // Busca todas as faturas pendentes do aluno
          const pendingInvoicesQuery = query(
            collection(db, "invoices"),
            where("studentId", "==", invoice.studentId),
            where("status", "in", ["pending", "overdue"])
          );
          const pendingInvoicesSnap = await getDocs(pendingInvoicesQuery);
          
          // Calcula novo status: se tem atrasadas = atrasado, se tem pendentes = pendente, sen√£o = em_dia
          const hasOverdue = pendingInvoicesSnap.docs.some(d => d.data().status === "overdue");
          const newPaymentStatus = hasOverdue ? "atrasado" : 
            pendingInvoicesSnap.docs.length > 0 ? "pendente" : "em_dia";
          
          await updateDoc(studentRef, {
            paymentStatus: newPaymentStatus,
          });
          
          // Envia notifica√ß√£o de pagamento confirmado
          await sendNotificationToStudent(invoice.studentId, {
            type: "payment_confirmed",
            title: "‚úÖ Pagamento Confirmado",
            message: `Seu pagamento de ${formatCurrency(invoice.amount)} foi confirmado com sucesso! Obrigado.`,
            invoiceId,
            amount: invoice.amount,
          });
        }
      } catch (e) {
        console.warn("Erro ao atualizar status do aluno ou enviar notifica√ß√£o:", e);
      }
    }
  }, [profile, sendNotificationToStudent]);

  const markAsOverdue = useCallback(async (invoiceId: string): Promise<void> => {
    const ref = doc(db, "invoices", invoiceId);
    const invoiceSnap = await getDoc(ref);
    
    if (!invoiceSnap.exists()) {
      throw new Error("Fatura n√£o encontrada");
    }
    
    const invoice = invoiceSnap.data() as Invoice;
    
    await updateDoc(ref, {
      status: "overdue",
      updatedAt: Date.now(),
    });
    
    // Envia notifica√ß√£o de atraso para o aluno
    await sendNotificationToStudent(invoice.studentId, {
      type: "overdue",
      title: "Pagamento em atraso",
      message: `Sua mensalidade de ${formatCurrency(invoice.amount)} est√° em atraso. Regularize seu pagamento.`,
      invoiceId,
      amount: invoice.amount,
      dueDate: invoice.lateDueDate || invoice.dueDate,
    });
  }, [sendNotificationToStudent]);

  // ========== TRANSA√á√ïES ==========

  const createTransaction = useCallback(async (
    data: Omit<Transaction, "id" | "createdAt" | "createdBy">
  ): Promise<string> => {
    if (!profile) throw new Error("Usu√°rio n√£o autenticado");

    const id = generateId("TXN");
    const transaction: Transaction = {
      ...data,
      id,
      createdAt: Date.now(),
      createdBy: profile.uid,
    };

    await setDoc(doc(db, "transactions", id), transaction);
    return id;
  }, [profile]);

  const fetchTransactions = useCallback(async (
    filters?: { type?: "income" | "expense"; month?: string }
  ): Promise<Transaction[]> => {
    try {
      const transactionsRef = collection(db, "transactions");
      let constraints: any[] = [];

      if (filters?.type) {
        constraints.push(where("type", "==", filters.type));
      }

      const q = constraints.length > 0 
        ? query(transactionsRef, ...constraints)
        : query(transactionsRef);
      
      const snap = await getDocs(q);
      let transactions = snap.docs.map(d => d.data() as Transaction);

      // Filtra por m√™s no cliente (para evitar √≠ndice composto)
      if (filters?.month) {
        transactions = transactions.filter(t => t.date.startsWith(filters.month!));
      }
      
      // Ordena por data
      return transactions.sort((a, b) => 
        new Date(b.date).getTime() - new Date(a.date).getTime()
      );
    } catch (e) {
      console.error("Erro ao buscar transa√ß√µes:", e);
      return [];
    }
  }, []);

  const deleteTransaction = useCallback(async (id: string): Promise<void> => {
    await deleteDoc(doc(db, "transactions", id));
  }, []);

  // ========== PIX ==========

  const generatePixCode = useCallback(async (invoice: Invoice): Promise<string> => {
    // Busca configura√ß√µes
    const settings = await getPaymentSettings();
    
    if (!settings?.pixKey) {
      throw new Error("Chave PIX n√£o configurada");
    }

    const txId = invoice.id.replace(/[^a-zA-Z0-9]/g, "").substring(0, 25);
    
    const pixCode = generatePixPayload(
      settings.pixKey,
      settings.pixKeyType,
      settings.pixReceiverName,
      settings.pixCity,
      invoice.amount,
      txId,
      invoice.description
    );

    // Salva o c√≥digo PIX na fatura
    await updateInvoice(invoice.id, {
      pixCode,
      pixExpiration: Date.now() + (24 * 60 * 60 * 1000), // 24 horas
    });

    return pixCode;
  }, [updateInvoice]);

  // ========== RELAT√ìRIOS ==========

  const getFinancialSummary = useCallback(async (month?: string): Promise<FinancialSummary> => {
    const currentMonth = month || new Date().toISOString().slice(0, 7);
    
    // Busca faturas do m√™s
    const invoices = await fetchInvoices({ month: currentMonth });
    
    // Busca transa√ß√µes do m√™s
    const transactions = await fetchTransactions({ month: currentMonth });

    const paid = invoices.filter(i => i.status === "paid");
    const pending = invoices.filter(i => i.status === "pending");
    const overdue = invoices.filter(i => i.status === "overdue");

    const totalReceived = transactions
      .filter(t => t.type === "income")
      .reduce((sum, t) => sum + t.amount, 0);

    const totalExpenses = transactions
      .filter(t => t.type === "expense")
      .reduce((sum, t) => sum + t.amount, 0);

    const totalPending = pending.reduce((sum, i) => sum + i.amount, 0);
    const totalOverdue = overdue.reduce((sum, i) => sum + i.amount, 0);

    return {
      totalReceived,
      totalPending,
      totalOverdue,
      totalExpenses,
      balance: totalReceived - totalExpenses,
      invoicesCount: {
        paid: paid.length,
        pending: pending.length,
        overdue: overdue.length,
      },
    };
  }, [fetchInvoices, fetchTransactions]);

  // ========== COBRAN√áAS EM LOTE ==========

  const generateMonthlyInvoices = useCallback(async (
    students: Profile[],
    month: string
  ): Promise<number> => {
    if (!profile) throw new Error("Usu√°rio n√£o autenticado");

    // Filtra apenas alunos ativos com turmas
    const eligibleStudents = students.filter(
      s => s.enrollmentStatus === "ativo" && s.classes && s.classes.length > 0
    );

    // Cria faturas
    let created = 0;
    for (const student of eligibleStudents) {
      try {
        const invoice = await generateInvoiceForStudent(student, month);
        if (invoice) created++;
      } catch (e) {
        console.error(`Erro ao criar fatura para ${student.name}:`, e);
      }
    }

    return created;
  }, [profile, fetchInvoices, createInvoice]);

  // ========== ATUALIZA√á√ÉO AUTOM√ÅTICA ==========

  const updateOverdueInvoices = useCallback(async (): Promise<number> => {
    const pendingInvoices = await fetchInvoices({ status: "pending" });
    
    let updated = 0;
    for (const invoice of pendingInvoices) {
      // Usa lateDueDate se dispon√≠vel, sen√£o usa dueDate
      const deadlineDate = invoice.lateDueDate || invoice.dueDate;
      if (isOverdue(deadlineDate)) {
        await markAsOverdue(invoice.id);
        updated++;
      }
    }

    return updated;
  }, [fetchInvoices, markAsOverdue]);

  // ========== CONFIGURA√á√ïES ==========

  // Valores padr√£o para teste (abaixo de R$ 10)
  const DEFAULT_TIER_PRICING: TierPricing[] = [
    { classes: 1, earlyPrice: 990, regularPrice: 1090 },   // R$ 9,90 | R$ 10,90
    { classes: 2, earlyPrice: 1780, regularPrice: 1980 },  // R$ 17,80 | R$ 19,80
    { classes: 3, earlyPrice: 2520, regularPrice: 2820 },  // R$ 25,20 | R$ 28,20
    { classes: 4, earlyPrice: 3160, regularPrice: 3560 },  // R$ 31,60 | R$ 35,60
  ];

  const getPaymentSettings = useCallback(async (): Promise<PaymentSettings | null> => {
    try {
      const settingsRef = collection(db, "settings");
      const q = query(settingsRef, where("type", "==", "payment"));
      const snap = await getDocs(q);
      
      if (snap.empty) {
        // Retorna configura√ß√µes padr√£o para teste
        return {
          monthlyFee: 1090, // R$ 10,90 (1 turma, pre√ßo normal)
          pixKey: "",
          pixKeyType: "cpf",
          pixReceiverName: "CDMF",
          pixCity: "SAO PAULO",
          dueDayOfMonth: 1, // dia 1 para desconto
          gracePeriodDays: 7, // at√© dia 8
          latePaymentDeadline: 8, // √∫ltimo dia
          tierPricing: DEFAULT_TIER_PRICING,
        };
      }
      
      const data = snap.docs[0].data() as PaymentSettings;
      // Garante que tierPricing existe
      if (!data.tierPricing || data.tierPricing.length === 0) {
        data.tierPricing = DEFAULT_TIER_PRICING;
      }
      return data;
    } catch (e) {
      console.error("Erro ao buscar configura√ß√µes:", e);
      return null;
    }
  }, []);

  const updatePaymentSettings = useCallback(async (settings: Partial<PaymentSettings>): Promise<void> => {
    const ref = doc(db, "settings", "payment");
    await setDoc(ref, { ...settings, type: "payment", updatedAt: Date.now() }, { merge: true });
  }, []);

  // Calcula pre√ßo baseado no n√∫mero de turmas
  const calculatePriceForStudent = useCallback((
    classCount: number, 
    settings: PaymentSettings
  ): { earlyPrice: number; regularPrice: number; discount: number } => {
    const count = Math.max(1, Math.min(classCount, 4)); // Limite de 1 a 4 turmas
    
    const tier = settings.tierPricing?.find(t => t.classes === count) 
      || settings.tierPricing?.[count - 1]
      || { earlyPrice: settings.monthlyFee, regularPrice: settings.monthlyFee };
    
    return {
      earlyPrice: tier.earlyPrice,
      regularPrice: tier.regularPrice,
      discount: tier.regularPrice - tier.earlyPrice,
    };
  }, []);

  // Gera fatura autom√°tica para um aluno
  const generateInvoiceForStudent = useCallback(async (
    student: Profile,
    month: string // "2025-01"
  ): Promise<Invoice | null> => {
    if (!profile) throw new Error("Usu√°rio n√£o autenticado");
    
    const settings = await getPaymentSettings();
    if (!settings) throw new Error("Configura√ß√µes de pagamento n√£o encontradas");
    
    // Busca turmas ativas onde o aluno est√° realmente inscrito (pela lista de studentIds da turma)
    const classesRef = collection(db, "classes");
    const classesSnap = await getDocs(classesRef);
    const activeClasses = classesSnap.docs
      .map(doc => doc.data() as Class)
      .filter(c => c.active && c.studentIds?.includes(student.uid));
    
    const classCount = activeClasses.length;
    const classIds = activeClasses.map(c => c.id);
    
    if (classCount === 0) {
      console.log(`Aluno ${student.name} n√£o est√° em nenhuma turma ativa`);
      return null;
    }
    
    // Verifica se j√° existe fatura para este m√™s
    const existing = await fetchInvoices({ studentId: student.uid, month });
    if (existing.length > 0) {
      console.log(`Fatura j√° existe para ${student.name} em ${month}`);
      return existing[0];
    }
    
    const prices = calculatePriceForStudent(classCount, settings);
    
    // Calcula as datas de vencimento
    const [year, monthNum] = month.split("-").map(Number);
    const dueDayStr = settings.dueDayOfMonth.toString().padStart(2, "0");
    const lateDayStr = settings.latePaymentDeadline.toString().padStart(2, "0");
    const dueDate = `${year}-${monthNum.toString().padStart(2, "0")}-${dueDayStr}`;
    const lateDueDate = `${year}-${monthNum.toString().padStart(2, "0")}-${lateDayStr}`;
    
    // Verifica se ainda est√° no per√≠odo de desconto
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const earlyDeadline = new Date(dueDate + "T23:59:59");
    earlyDeadline.setHours(23, 59, 59, 999);
    const isEarlyPayment = today <= earlyDeadline;
    
    const currentAmount = isEarlyPayment ? prices.earlyPrice : prices.regularPrice;
    const discountValue = isEarlyPayment ? prices.discount : 0;
    
    // Monta descri√ß√£o detalhada
    let description = `Mensalidade ${getMonthName(monthNum)}/${year} - ${classCount} turma${classCount > 1 ? "s" : ""}`;
    
    if (isEarlyPayment && discountValue > 0) {
      const discountPercent = Math.round((discountValue / prices.regularPrice) * 100);
      description += ` | üí∞ Desconto de ${formatCurrency(discountValue)} (${discountPercent}%) aplicado - Pagamento at√© ${formatDateSafe(dueDate)}`;
    } else {
      description += ` | ‚è∞ Valor padr√£o - Prazo de desconto encerrado`;
    }
    
    const id = generateId("INV");
    const invoice: Invoice = {
      id,
      studentId: student.uid,
      studentName: student.name,
      studentEmail: student.email,
      amount: currentAmount,
      originalAmount: prices.regularPrice,
      discountAmount: discountValue,
      description,
      dueDate,
      lateDueDate,
      status: "pending",
      referenceMonth: month,
      classIds,
      classCount,
      createdAt: Date.now(),
      createdBy: profile.uid,
      isAutoGenerated: true,
    };
    
    await setDoc(doc(db, "invoices", id), invoice);
    
    // Atualiza status de pagamento do aluno
    try {
      const studentRef = doc(db, "profiles", student.uid);
      const studentSnap = await getDoc(studentRef);
      if (studentSnap.exists()) {
        // Busca todas as faturas pendentes do aluno
        const pendingInvoicesQuery = query(
          collection(db, "invoices"),
          where("studentId", "==", student.uid),
          where("status", "in", ["pending", "overdue"])
        );
        const pendingInvoicesSnap = await getDocs(pendingInvoicesQuery);
        
        // Calcula novo status: se tem atrasadas = atrasado, se tem pendentes = pendente, sen√£o = em_dia
        const hasOverdue = pendingInvoicesSnap.docs.some(d => d.data().status === "overdue");
        const newPaymentStatus = hasOverdue ? "atrasado" : 
          pendingInvoicesSnap.docs.length > 0 ? "pendente" : "em_dia";
        
        await updateDoc(studentRef, {
          paymentStatus: newPaymentStatus,
        });
      }
    } catch (e) {
      console.warn("Erro ao atualizar status do aluno:", e);
    }
    
    // Envia notifica√ß√£o para o aluno
    await sendNotificationToStudent(student.uid, {
      type: "billing",
      title: "Nova mensalidade gerada",
      message: `Sua mensalidade de ${formatCurrency(currentAmount)} para ${formatDateSafe(month)} est√° dispon√≠vel.`,
      invoiceId: id,
      amount: currentAmount,
      dueDate,
    });
    
    // Cria atividade para o log de atividades recentes
    try {
      const activityId = generateId("ACT");
      const activitiesRef = collection(db, "activities");
      await setDoc(doc(activitiesRef, activityId), {
        id: activityId,
        type: "invoice_generated",
        title: "Cobran√ßa gerada",
        description: `Mensalidade de ${formatCurrency(currentAmount)} gerada para ${student.name}`,
        timestamp: Date.now(),
        metadata: {
          studentId: student.uid,
          studentName: student.name,
          invoiceId: id,
          amount: currentAmount,
        },
        read: false,
        createdBy: profile.uid,
      });
    } catch (e) {
      console.warn("Erro ao criar atividade:", e);
    }
    
    return invoice;
  }, [profile, getPaymentSettings, calculatePriceForStudent, fetchInvoices, sendNotificationToStudent]);

  // ==================== LISTENERS EM TEMPO REAL ====================

  // Listener para faturas de um aluno espec√≠fico
  const subscribeToInvoices = useCallback((
    studentId: string,
    callback: (invoices: Invoice[]) => void
  ): (() => void) => {
    const invoicesRef = collection(db, "invoices");
    
    // Query simples sem orderBy para evitar necessidade de √≠ndice composto
    // A ordena√ß√£o √© feita no cliente
    const q = query(
      invoicesRef, 
      where("studentId", "==", studentId)
    );

    const unsubscribe = onSnapshot(q, (snapshot) => {
      const invoices = snapshot.docs.map(doc => doc.data() as Invoice);
      // Ordena por data de cria√ß√£o (mais recente primeiro) no cliente
      invoices.sort((a, b) => b.createdAt - a.createdAt);
      callback(invoices);
    }, (error) => {
      console.error("Erro no listener de faturas:", error);
      // Em caso de erro, retorna array vazio para n√£o deixar carregando infinitamente
      callback([]);
    });

    return unsubscribe;
  }, []);

  // Listener para TODAS as faturas (usado pelo master)
  const subscribeToAllInvoices = useCallback((
    callback: (invoices: Invoice[]) => void,
    filters?: { status?: PaymentStatus | PaymentStatus[]; month?: string }
  ): (() => void) => {
    const invoicesRef = collection(db, "invoices");
    
    // Query sem filtros complexos para evitar necessidade de √≠ndices
    const unsubscribe = onSnapshot(invoicesRef, (snapshot) => {
      let invoices = snapshot.docs.map(doc => doc.data() as Invoice);
      
      // Aplica filtros no cliente
      if (filters?.status) {
        const statusArray = Array.isArray(filters.status) ? filters.status : [filters.status];
        invoices = invoices.filter(inv => statusArray.includes(inv.status));
      }
      
      if (filters?.month) {
        invoices = invoices.filter(inv => inv.referenceMonth === filters.month);
      }
      
      // Ordena por data de cria√ß√£o (mais recente primeiro)
      invoices.sort((a, b) => b.createdAt - a.createdAt);
      callback(invoices);
    }, (error) => {
      console.error("Erro no listener de todas as faturas:", error);
      callback([]);
    });

    return unsubscribe;
  }, []);

  // Listener para configura√ß√µes de pagamento
  const subscribeToSettings = useCallback((
    callback: (settings: PaymentSettings | null) => void
  ): (() => void) => {
    const settingsRef = doc(db, "settings", "payment");

    const unsubscribe = onSnapshot(settingsRef, (snapshot) => {
      if (snapshot.exists()) {
        const data = snapshot.data() as PaymentSettings;
        // Garante que tierPricing existe
        if (!data.tierPricing || data.tierPricing.length === 0) {
          data.tierPricing = [
            { classes: 1, earlyPrice: 990, regularPrice: 1090 },
            { classes: 2, earlyPrice: 1780, regularPrice: 1980 },
            { classes: 3, earlyPrice: 2520, regularPrice: 2820 },
            { classes: 4, earlyPrice: 3160, regularPrice: 3560 },
          ];
        }
        callback(data);
      } else {
        // Retorna configura√ß√µes padr√£o
        callback({
          monthlyFee: 1090,
          pixKey: "",
          pixKeyType: "cpf",
          pixReceiverName: "CDMF",
          pixCity: "SAO PAULO",
          dueDayOfMonth: 1,
          gracePeriodDays: 7,
          latePaymentDeadline: 8,
          tierPricing: [
            { classes: 1, earlyPrice: 990, regularPrice: 1090 },
            { classes: 2, earlyPrice: 1780, regularPrice: 1980 },
            { classes: 3, earlyPrice: 2520, regularPrice: 2820 },
            { classes: 4, earlyPrice: 3160, regularPrice: 3560 },
          ],
        });
      }
    }, (error) => {
      console.error("Erro no listener de configura√ß√µes:", error);
      callback(null);
    });

    return unsubscribe;
  }, []);

  // Limpa todos os dados financeiros (faturas, transa√ß√µes e status dos alunos)
  const clearAllFinancialData = useCallback(async (): Promise<{ invoices: number; transactions: number; studentsUpdated: number }> => {
    if (!profile || profile.role !== "master") {
      throw new Error("Apenas o administrador pode limpar dados financeiros");
    }

    let invoicesDeleted = 0;
    let transactionsDeleted = 0;
    let studentsUpdated = 0;

    // 1. Deleta todas as faturas
    const invoicesSnap = await getDocs(collection(db, "invoices"));
    for (const docSnap of invoicesSnap.docs) {
      await deleteDoc(doc(db, "invoices", docSnap.id));
      invoicesDeleted++;
    }

    // 2. Deleta todas as transa√ß√µes
    const transactionsSnap = await getDocs(collection(db, "transactions"));
    for (const docSnap of transactionsSnap.docs) {
      await deleteDoc(doc(db, "transactions", docSnap.id));
      transactionsDeleted++;
    }

    // 3. Atualiza o status de pagamento de todos os alunos para "sem_cobranca"
    // e limpa as notifica√ß√µes de pagamento
    const studentsQuery = query(collection(db, "profiles"), where("role", "==", "student"));
    const studentsSnap = await getDocs(studentsQuery);
    for (const docSnap of studentsSnap.docs) {
      await updateDoc(doc(db, "profiles", docSnap.id), {
        paymentStatus: "sem_cobranca",
        pendingNotifications: [],
      });
      studentsUpdated++;
    }

    return { invoices: invoicesDeleted, transactions: transactionsDeleted, studentsUpdated };
  }, [profile]);

  // ==================== VALUE ====================

  const value = useMemo(
    () => ({
      // Faturas
      createInvoice,
      fetchInvoices,
      updateInvoice,
      deleteInvoice,
      markAsPaid,
      markAsOverdue,
      // Transa√ß√µes
      createTransaction,
      fetchTransactions,
      deleteTransaction,
      // PIX
      generatePixCode,
      // Relat√≥rios
      getFinancialSummary,
      // Lote
      generateMonthlyInvoices,
      updateOverdueInvoices,
      // Configura√ß√µes
      getPaymentSettings,
      updatePaymentSettings,
      // C√°lculo de pre√ßos
      calculatePriceForStudent,
      // Gera√ß√£o autom√°tica
      generateInvoiceForStudent,
      // Listeners em tempo real
      subscribeToInvoices,
      subscribeToAllInvoices,
      subscribeToSettings,
      // Administra√ß√£o
      clearAllFinancialData,
    }),
    [
      createInvoice,
      fetchInvoices,
      updateInvoice,
      deleteInvoice,
      markAsPaid,
      markAsOverdue,
      createTransaction,
      fetchTransactions,
      deleteTransaction,
      generatePixCode,
      getFinancialSummary,
      generateMonthlyInvoices,
      updateOverdueInvoices,
      getPaymentSettings,
      updatePaymentSettings,
      calculatePriceForStudent,
      generateInvoiceForStudent,
      subscribeToInvoices,
      subscribeToAllInvoices,
      subscribeToSettings,
      clearAllFinancialData,
    ]
  );

  return <PaymentContext.Provider value={value}>{children}</PaymentContext.Provider>;
}

export function usePayment() {
  const ctx = useContext(PaymentContext);
  if (!ctx) throw new Error("usePayment must be used within <PaymentProvider>");
  return ctx;
}

